---
title: 'Process IUCN spp shapes provided individually'
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(fig.width = 6, fig.height = 4, fig.path = 'Figs/',
                      echo = TRUE, message = FALSE, warning = FALSE)

library(raster)
library(rgeos)
source('https://raw.githubusercontent.com/oharac/src/master/R/common.R')

library(sf)

dir_git <- '~/github/spp_risk_dists'
dir_o_anx <- file.path(dir_O, 'git-annex/spp_risk_dists')

### project specific folders and info
source(file.path(dir_git, 'data_setup/common_fxns.R'))

dir_zips <- file.path(dir_M, 'git-annex/globalprep',
                     '_raw_data/iucn_spp/zips_from_iucn_2018')
unzip_dirs <- list.dirs(dir_zips) %>%
  .[. != dir_zips] ### exclude home (dir_zips) from results
  ### These are shapefiles directly from IUCN as individual species map files;
  ### these will be handled differently from those taken from Red List Spatial
  ### Data Download page

dir_shp <- file.path(dir_M, 'git-annex/globalprep',
                     '_raw_data/iucn_spp/d2018-1')

### Gall-Peters doesn't have an EPSG?
gp_proj4 <- '+proj=cea +lon_0=0 +lat_ts=45 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs'

```

# Summary

Gather individually provided species shapefiles into taxa shapefiles for easier processing.

# Data source

IUCN: Gina Ralph direct communication

# Methods

## Read spp shapes, trim to +/-180 deg, save as taxa level shapefiles

``` {r define fxn}
### Define helper function to cleanly get the info from DBF files,
### including colname checks
get_dbf <- function(x) { ### x <- shps_dbfs[1]
  spp_dbf_info <- foreign::read.dbf(x, as.is = TRUE) %>%
    clean_df_names()
  
  ### Individual files call the id number 'iucn_sid'; bli has been fixed to
  ### 'iucn_sid' as well; Red List Data Download files are 'id_no'... So:
  ### fix that here!
  names(spp_dbf_info)[names(spp_dbf_info) == 'id_no'] <- 'iucn_sid'
  
  ### Some files (e.g. bli and individual files) don't have 'subpop':
  ### add it in as NAs.
  if(!'subpop' %in% names(spp_dbf_info)) spp_dbf_info$subpop <- NA
  
  ### some files don't have 'presence' field: if not present or NA,
  ### set to presence = 1.  Some have presence = 0?
  if(!'presence' %in% names(spp_dbf_info)) spp_dbf_info$presence <- 1
  
  spp_dbf_info <- spp_dbf_info %>%
    mutate(presence = ifelse(presence == 0, 1, presence))
  
  return(spp_dbf_info)
}
```

### Check the validity and bounds of all spp shapefiles

``` {r gather all ids and check bounds, eval = FALSE}
reload <- FALSE

shps <- list.files(unzip_dirs, pattern = '\\.shp$', 
                   recursive = FALSE, full.names = TRUE)

system.time({
  spp_bounds_list <- parallel::mclapply(shps, mc.cores = 12, FUN = function(shp) {
  # for(shp in shps) {
    ### shp <- shps[1]

    spp_sf <- read_sf(shp)
    
    spp_bbox <- st_bbox(spp_sf)
    spp_valid <- st_is_valid(spp_sf)
    
    spp_df <- data.frame(iucn_sid = spp_sf$iucn_sid,
                         spp_shp = shp,
                         valid = spp_valid,
                         xmin = spp_bbox$xmin,
                         xmax = spp_bbox$xmax,
                         ymin = spp_bbox$ymin,
                         ymax = spp_bbox$ymax) %>%
      mutate(exceeds_bounds = (xmin < -180 | xmax > 180))
    
  }) ### end of mclapply
}) ### end of system.time

spp_bounds_df <- bind_rows(spp_bounds_list) %>%
  distinct()

write_csv(spp_bounds_df, file.path(dir_git, 'data/map_check', 'spp_bounds.csv'))

```

### Attempt to trim problem files

After trimming, overwrite the original shapefiles (we still have the ZIPs for *original* originals)

``` {r attempt to trim indiv shapefiles and overwrite, eval = FALSE}
### This will try to fix each original shapefile from IUCN by clipping
### bounds to +/- 180 (only for those that exceed those bounds).

spp_bounds_df <- read_csv(file.path(dir_git, 'data/map_check', 'spp_bounds.csv'))
cat_msg('Spp shapes that exceed x bounds: ', sum(spp_bounds_df$exceeds_bounds))

shps_to_fix <- spp_bounds_df %>%
  filter(exceeds_bounds)

spp_bounds_list <- parallel::mclapply(seq_along(shps_to_fix$iucn_sid),
                                        mc.cores = 12, FUN = function(i) {
  ### i <- 1

  shp_file <- shps_to_fix$spp_shp[i]
  spp_sf <- read_sf(shp_file)
  spp_valid <- shps_to_fix$valid[i]
  
  if(!spp_valid) {
    cat_msg(shp_file, ': invalid geometry; buffering zero distance')
    spp_sf <- st_buffer(spp_sf, 0)
  }
  
  ### if sf version (st_crop) fails, try with raster version (raster::crop)
  tryCatch(spp_sf_trim <- clip_to_globe(spp_sf), 
           finally = spp_sf_trim <- clip_to_globe_sp(spp_sf))

  write_sf(spp_sf_trim, shp_file, driver = 'ESRI Shapefile')

}) ### end of mclapply

```

## Combine spp shapes into taxa shapes

### Identify the species and taxa from the dbfs
``` {r generate map list from dbfs}


iucn_indiv_dbfs <- list.files(unzip_dirs, pattern = '\\.dbf$', 
                              recursive = FALSE,
                              full.names = TRUE)

map_info_list <- lapply(iucn_indiv_dbfs, get_dbf) %>%
  setNames(iucn_indiv_dbfs)

map_info_raw <- bind_rows(map_info_list, .id = 'dbf_file') %>%
  select(iucn_sid, 
         sciname = binomial, 
         presence, 
         subpop, 
         dbf_file) %>%
  distinct()
### Notes on presence, origin, seasonal fields:
### * presence = 5 is extinct; 4 = probably extinct; others are extant-ish or 
###   uncertain. We will drop field and include all polygons for now.
### * origin is native, introduced, etc.  We will drop this field and not
###   worry about origin.
### * seasonal is breeding/non-breeding/passage.  We will drop this field
###   and not worry about seasonality.

### filter to marine habitat species (to drop terrestrial reptiles e.g.)
marine_spp_ids <- read_csv(file.path(dir_git, 'data',
                                     sprintf('spp_marine_from_api_%s.csv', 
                                             api_version)),
                           col_types = 'dcc') %>%
  select(iucn_sid, max_depth)
### Find taxonomic info and attach
spp_taxa <- read_csv(file.path(dir_o_anx, 'iucn',
                               sprintf('spp_info_from_api_%s.csv', api_version)),
                     col_types = 'dcccc_____') %>%
  mutate(phylum = tolower(phylum),
         class  = tolower(class),
         order  = tolower(order))

marine_map_info <- map_info_raw %>%
  inner_join(marine_spp_ids, by = 'iucn_sid') %>%
  inner_join(spp_taxa, by = 'iucn_sid') %>%
  mutate(taxon = case_when(class  == 'actinopterygii' ~ order,
                           phylum == 'chordata'       ~ class,
                           TRUE                       ~ phylum))

write_csv(marine_map_info, file.path(dir_git, 'data/map_check', 'marine_spp_processed.csv'))
```

### Gather the species by taxa and save as a taxa-level shapefile

Note this excludes problem species noted below.  Those will need to be examined manually and fixed, then the above chunks (currently set as eval = FALSE) will need to be rerun to update the spp_bounds.csv file.

``` {r gather ids and read into a single shapefile}

reload <- FALSE

spp_probs <- read_csv(file.path(dir_git, 'data/map_check', 'spp_bounds.csv')) %>%
  filter(exceeds_bounds)

maps_shps <- read_csv(file.path(dir_git, 'data/map_check', 'marine_spp_processed.csv')) %>%
  mutate(shp_file = str_replace(dbf_file, '\\.dbf$', '.shp')) %>%
  filter(!iucn_sid %in% spp_probs)
  

taxa <- maps_shps$taxon %>% unique() %>% sort()
  
for(taxon_gp in taxa) { ### taxon_gp <- taxa[15]
  taxon_shps <- maps_shps %>%
    filter(taxon == taxon_gp)
  
  cat_msg('Processing ', taxon_gp, ' with ', nrow(taxon_shps), ' separate spp files')
  
  outfile <- file.path(dir_shp, paste0(taxon_gp, '.shp'))
  
  if(!file.exists(outfile) | reload == TRUE) {
  
    shps_list <- lapply(taxon_shps$shp_file, read_sf)
    
    polys_all <- do.call(rbind, shps_list) %>%
      ### allows to pass a *list* of arguments to a function separately!
      clean_df_names() %>%
      mutate(iucn_sid = as.numeric(iucn_sid))
    
    ### clean up the attributes of resulting sf object
    if(!'subpop' %in% names(polys_all)) {
      polys_all$subpop <- NA_character_
      ### if shape doesn't have subpop column, add it as NA
    }
    if('id_no' %in% names(polys_all)) {
      polys_all <- polys_all %>%
        rename(iucn_sid = id_no)
    }
    if(!'presence' %in% names(polys_all)) {
      polys_all <- polys_all %>%
        mutate(presence = 1)
    }
    
    if(any(polys_all$iucn_sid > 1e8)) {
      cat_msg("don't freak out about the error message - the field seems fine")
    }
    st_write(polys_all, outfile, driver = 'ESRI Shapefile',
             delete_layer = TRUE)
    
    
  } else {
    cat_msg('Shapefile found: ', outfile)
  }
}

```

## Species shapes with problems still to fix

``` {r}
spp_probs <- read_csv(file.path(dir_git, 'data/map_check', 'spp_bounds.csv')) %>%
  filter(exceeds_bounds) %>%
  mutate(spp_shp = basename(spp_shp))

DT::datatable(spp_probs)

```
