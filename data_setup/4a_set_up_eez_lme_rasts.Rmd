---
title: 'Rasterize EEZs, LMEs, and Bathymetry'
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(fig.width = 6, fig.height = 4, fig.path = 'Figs/',
                      echo = TRUE, message = FALSE, warning = FALSE)

library(raster)
library(sf)
source('https://raw.githubusercontent.com/oharac/src/master/R/common.R')


dir_git <- '~/github/spp_health_dists'
dir_o_anx <- file.path(dir_O, 'git-annex/spp_health_dists')

### goal specific folders and info
dir_check   <- file.path(dir_git, 'data/iucn/map_check')

dir_shp <- file.path(dir_M, 'git-annex/globalprep/_raw_data/iucn_spp/d2017-3')

### provenance tracking
# library(provRmd); prov_setup()

```

# Summary

Set up analysis rasters for EEZs, LMEs, and bathymetry at a 0.1° lat-long resolution.

* EEZs will include all EEZs as well as FAO regions and CCAMLR regions, based on the global OHI EEZ map.
* LMEs will include all LMEs, though only some are appropriate for IUCN regional assessments (see `2a_set_up_regional_codes.Rmd`).
* Bathymetry will include regions for 200m+, 20-200m, and <20m.  
* All will be clipped to the same ocean presence using the EEZ raster.

# Methods

## EEZ raster

Using the OHI global EEZ shapefile, we will include all EEZs by OHI region code, as well as FAO regions and Antarctica, using unique identifiers.  This will allow for separation by high seas vs. EEZ, or different takes on IUCN regional assessments using FAO or EEZ identifiers.

``` {r set up EEZ raster}

eez_rast_file <- file.path(dir_git, 'spatial', 'eez_rast_010_wgs84.tif')
eez_shp_file  <- file.path(dir_M, 'git-annex/globalprep/spatial/v2017/regions_2017_update.shp')

if(!file.exists(eez_rast_file)) {
  eez_shp <- st_read(eez_shp_file)
  
  eez_df <- eez_shp %>%
    as.data.frame() %>%
    dplyr::select(-geometry)
  eez_ids <- eez_df %>%
    select(rgn_id, rgn_name, rgn_ant_id) %>%
    distinct()
  ### rgn_ant_id is same as rgn_id except for Antarctica.  We don't really
  ### need to chunk out Antarctica at this point so just use rgn_id.
  ### Filter out all land polygons and project back to WGS84 (4326) since
  ### this shapefile is in Mollweide.
  
  eez_shp_reclass <- eez_shp %>%
    # mutate(rgn_id_reclass = ifelse(str_detect(rgn_type, '^land'), 0, rgn_id)) %>%
    filter(!str_detect(rgn_type, '^land')) %>%
    select(rgn_id, geometry) %>%
    st_transform(4326)
  
  plot(eez_shp_reclass)
  
  rast_base_tenthdeg <- raster::raster(resolution = .10, 
                                       ext = extent(c(-180, 180, -90, 90)))
  
  eez_rast <- fasterize::fasterize(eez_shp_reclass, rast_base_tenthdeg, 
                                   field = 'rgn_id', fun = 'min')
  
  plot(eez_rast, main = 'EEZ raster 0.10 deg lat-long')
    
  writeRaster(eez_rast, eez_rast_file, overwrite = TRUE)
} else {
  # git_prov(eez_shp_file, 'input')
  # git_prov(eez_rast_file, 'output')
  plot(raster::raster(eez_rast_file), main = 'EEZ raster 0.10 deg lat-long')
}
```

## LME raster

Using the LME shapefile, we will include all MLEs and then mask out land using the EEZ raster (for consistency).

``` {r set up LME raster}

lme_rast_file <- file.path(dir_git, 'spatial', 'lme_rast_010_wgs84.tif')
lme_shp_file  <- file.path(dir_o_anx, 'lme/LME66', 'LMEs66.shp')

if(!file.exists(lme_rast_file)) {
  lme_shp <- st_read(lme_shp_file)
  
  
  lme_shp_reclass <- lme_shp %>%
    select(LME_NUMBER, geometry) %>%
    st_transform(4326)
  
  plot(lme_shp_reclass)
  
  rast_base_tenthdeg <- raster::raster(resolution = .10, 
                                       ext = extent(c(-180, 180, -90, 90)))
  
  lme_rast <- fasterize::fasterize(lme_shp_reclass, rast_base_tenthdeg, 
                                   field = 'LME_NUMBER', fun = 'min')
  
  lme_rast[is.na(eez_rast)] <- NA
  plot(lme_rast, main = 'LME raster 0.10 deg lat-long')
    
  ### check whether there are shoreline gaps between LME maps and EEZ maps
  # x <- eez_rast
  # x[!is.na(values(lme_rast))] <- NA
  # plot(x)
  ### small artifacts around the edges... not enough to worry about?
  
  writeRaster(lme_rast, lme_rast_file, overwrite = TRUE)
} else {
  # git_prov(lme_shp_file, 'input')
  # git_prov(lme_rast_file, 'output')
  plot(raster::raster(lme_rast_file), main = 'LME raster 0.10 deg lat-long')
}
```


## Bathymetry raster

Using [General Bathymetric Chart of the Oceans (GEBCO) bathymetry raster](https://www.bodc.ac.uk/data/hosted_data_systems/gebco_gridded_bathymetry_data/), identify min depth of ocean cells.  For neritic and coastal cells, leaving as min depth allows for changing depth thresholds if desired.  We will not clip based on anything below 200 m, so can classify these more coarsely.

NOTE: 1 arcmin and 30 arcsec are available; 30 arcsec is more recent but one arcmin should be sufficient for our purposes.  Resample to 6 arc-minute (0.10°) using min depth in each cell.

### Create and view minimum depth raster

``` {r set up bathymetry raster}

bathy_rast_file <- file.path(dir_git, 'spatial', 'bathy_rast_010_wgs84.tif')

gebco_rast_file <- file.path(dir_o_anx, 'gebco', 'GRIDONE_1D.nc')
gebco_rast_raw  <- raster(gebco_rast_file)

if(!file.exists(bathy_rast_file)) {
  ### The GEBCO raster is elevation, so depth is neg... for min depth, 
  ### aggregate by max (and vice versa)
  bathy_rast_min <- gebco_rast_raw %>%
    raster::aggregate(fact = 6, fun = max)
  
  bathy_rast_min <- -1 * bathy_rast_min
    
  rast_base_tenthdeg <- raster::raster(resolution = .10, 
                                       ext = extent(c(-180, 180, -90, 90)))
  
  bathy_rast_raw <- bathy_rast_min %>%
    raster::resample(rast_base_tenthdeg, 
                     # progress = 'text',
                     method = 'ngb')
  
  ### reclassify:
  ### compress cells above zero to sea level;
  ### compress cells below 200 m to rough depth clips
  bathy_rast <- bathy_rast_raw
  values(bathy_rast)[values(bathy_rast_raw) < 0] <- 0
  values(bathy_rast)[values(bathy_rast_raw) > 200] <- 1000
  values(bathy_rast)[values(bathy_rast_raw) > 1000] <- 2000
  values(bathy_rast)[values(bathy_rast_raw) > 2000] <- 3000
  values(bathy_rast)[values(bathy_rast_raw) > 3000] <- 4000
  values(bathy_rast)[values(bathy_rast_raw) > 4000] <- 5000
  values(bathy_rast)[values(bathy_rast_raw) > 5000] <- 6000
  values(bathy_rast)[values(bathy_rast_raw) > 6000] <- 7000
  values(bathy_rast)[values(bathy_rast_raw) > 7000] <- 8000
  plot(bathy_rast, main = 'Bathymetry (minimum depth) raster 0.10 deg lat-long')
    
  ### check whether there are shoreline gaps between LME maps and EEZ maps
  # x <- eez_rast
  # x[!is.na(values(lme_rast))] <- NA
  # plot(x)
  ### small artifacts around the edges... not enough to worry about?
  
  writeRaster(bathy_rast, bathy_rast_file, overwrite = TRUE)
  
} else {
  # git_prov(bathy_rast_file, 'output')
  plot(raster::raster(bathy_rast_file), main = 'Bathymetry (minimum depth) raster 0.10 deg lat-long')
}
```

### Viewing categories: 0-60, 60-200, 200+ m depths

``` {r plot bathy raster categories}

bathy_rast <- raster(bathy_rast_file)
bathy_rast_cats <- raster(bathy_rast_file)

values(bathy_rast_cats)[values(bathy_rast)  >= 0] <- 1
values(bathy_rast_cats)[values(bathy_rast)  > 60] <- 2
values(bathy_rast_cats)[values(bathy_rast) > 200] <- 3

plot(bathy_rast_cats, main = 'bathymetry categories: <=60m = 1, <=200 m = 2, >200m = 3')

y <- bathy_rast %>%
  crop(extent(c(-122, -116, 31, 35)))
values(y)[values(y) <= 0] <- NA
plot(y, main = 'bathymetry, SB Channel Islands')

x <- bathy_rast_cats %>%
  crop(extent(c(-122, -116, 31, 35)))
values(x)[is.na(values(y))] <- NA
plot(x, main = 'bathymetry categories: <=60m = 1, <=200 m = 2, >200m = 3')

```


-----

``` {r prov_footer, results = 'asis'}

# prov_wrapup(commit_outputs = FALSE)

```

